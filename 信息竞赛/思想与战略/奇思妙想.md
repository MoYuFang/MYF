#### 2021.9.16

一种密码防窃听方式：

设密码 $S$ 由 $s_i$ 共 $n$ 个字符组成，一开始密码由服务器与用户共同拥有。

每次登时服务器会进行 $m$ 次验证，每次验证中会随机生成 $n$ 个数 $a_i$ 及选择一个随机质数 $p$ 并发给用户。

用户收到后计算 $b_{user} = \sum_{i=1}^{n} s_i a_i\pmod p$，然后将 $b$ 发送给服务器。

服务器接收到 $b_{user}$ 后将其与服务器方计算的 $b_{serve}$ 比较并判断是否相等，若相等本次验证通过。

当所有验证都通过时密码正确，否则不正确。

每次登陆时传输的数据只有 $a_i$、$p$、$b_{user}$，并不包含真实密码。

#### 2022.02.21

一个长度为 $n$ 的 $01$ 字符串一共有 $2^n$ 种，现在我们想要构造一个长度为 $m$ 的 $01$ 字符串 $S_n$，使得任意长度为 $n$ 的 $01$ 字符串都是 $S$ 的子串，根据长度为 $l$ 的字符串一共有 $l-n+1$ 个长度为 $n$ 的子串，显然 $S$ 的长度 $m\ge 2^n+n-1$。

问 $\forall n\in\mathbb{N}$ 能否构造出 $m=O(2^n)$ 的 $S$。

一种 $\text{naive}$ 的做法是将所有长度为 $n$ 的 $01$ 字符串拼接成一个长度为 $n2^n$ 的字符串，这个字符串显然可以作为 $S_n$，所以 $m$ 的上界可以小到 $O(n2^n)$。