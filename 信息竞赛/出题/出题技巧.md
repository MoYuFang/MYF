$(1)$ 

**题面**

给定两个长度为 $n$ 数组 $a_i,b_i(0\le a_i,b_i\le 10^9)$，对于区间 $[l,r]$，定义贡献 $f(l,r)$
$$
f(l,r)=\max_{l\le i\le r}\{a_i\}\cdot\sum_{i=1}^{r}b_i
$$
再定义
$$
g(a,b)=\sum_{l=1}^{n}\sum_{r=l}^{n}f(l,r)
$$
有 $q$ 次修改操作，每次操作给出位置 $p(1\le p\le n)$ 和新值 $w(0\le w\le10^9)$，需要将 $b_p$ 修改成 $w$。

每次修改操作后要求回答 $g(a,b)$。

**数据范围**

$1\le n,q\le 10^6$

**分析**

先不考虑修改操作，看看 $g(a,b)$ 如何求。

$f(l,r)$ 的计算式里涉及两个部分，一个部分是区间最大值，一个部分是区间和，这提示我们固定 $\max\{a_i\}=t$，然后求有多少个区间里 $a_i$ 的 $\max$ 为 $t$，并将这些区间的 $b_i$ 加起来。

于是一个显然易见的算法就出来了。

用并查集维护区间块，每个区间块维护左端点和右端点，一开始区间块们长度为一，且是互相独立的和熄灭的，然后按 $a_i$ 从小到大加入，每加入一个 $a_i$ 就将那个位置上区间块点亮，并将所有点亮且相邻的区间块合并成同一区间。

合并后 $a_i$ 所在的区间块内的所有包含 $a_i$ 的子区间的 $\max$ 均为 $a_i$，固定了 $\max$ 后 $f(l,r)$ 的另一部分之和就容易用二次前缀和以 $O(1)$ 求出。

考虑修改操作，因为只修改 $b$，我们可以对上面的做法稍加修改。

首先答案肯定是
$$
\sum_{i=1}^{n}c_i\cdot b_i
$$
我们就需要求出系数数组 $c$。

对上面的做法稍加修改，计算每个 $b_i$ 的贡献，这需要用到区间二次加（比如给某区间加上等差数列 $[1,2,3,...,k]$），用二阶差分可以做到 $O(1)$ 区间二次加，全部加完后还要求两次前缀和。

总时间复杂度 $O(n+q)$。

**技巧**

这一题的出题技巧有三个

1. 贡献分多部分（这里是 $f(l,r)$ 分两部分）。
2. 求出 $b_i$ 的贡献系数后可进行单点修改操作。
3. 离线后用并查集合并求区间最大值。

**出一道不完全的题**

给定一颗树，节点 $u$ 上有点权 $a_u$。

对于一条路径 $P$，路径上的最大点权为 $M(P,a)$，则这条路径的贡献是 $f(P)=M(P,a)\cdot sth$，其中 $sth$ 是关于这条路径的某种属性。

现在要求回答所有路径中最大的 $f(P)$。



$(2)$ 异或的贡献可将路径问题转化为节点问题。

给定一颗树，树上每个节点 $u$ 都有点权 $a_u$，任选一个节点作为根，任意节点到根的路径的权值异或和为 $b_u$，则任意一条路径 $(u,v)$ 的异或和为 $b_u\oplus b_v$，这只与节点有关。



$(3)$ 出两颗树。

[P4565 [CTSC2018]暴力写挂](https://www.luogu.com.cn/problem/P4565) 

这道题中涉及到了两颗树，可以对第一颗树建立边分树，这个边分树相当是一颗 $\text{01-Trie}$ 树，然后再在第二颗树上 $\text{dfs}$ 并用线段树合并计算贡献。



$(4)$ 线段树上的颜色段均摊。

**题面**

给定一个长度为 $n$ 的序列 $a$，$a_i$ 是权值。给定 $m$ 个区间 $s_i=[l_i,r_i]$。给定 $q$ 次询问，每次询问给出区间 $[l,r]$，要求回答 $\displaystyle \bigcup_{i=l}^{r}s_i$ 上的权值和。

**数据范围**

$1\le l_i\le r_i\le n\le 5\cdot 10^5,\ 1\le l\le r\le m\le 10^5,\ q\le 10^5,\ 1\le a_i\le 10^9$。

**分析**

因为去重问题，在线做十分麻烦，时间复杂度降不下来。

考虑将询问离线，以 $r$ 为关键字排序询问。

按顺序处理区间 $s_i$，每次将 $[l_i,r_i]$ 上的颜色染成 $i$，则一次对 $[l,r]$ 的询问转化成求序列中颜色值 $\in[l,r]$ 的权值和。

对区间的染色用线段树的区间覆盖处理，然后用另外一个数据结构维护每种颜色的权值和为多少。

线段树在区间覆盖时，若将要 $\text{spread}$ 一个节点（也就是说这个节点对应区间被整体覆盖），必须用 $\text{dfs}$ 清除这个节点子树下的所有旧有标记，并在另一个数据结构上做相应修改。

若这个子树下已无任何标记则不需要再向下 $\text{dfs}$ 了。

注意线段树仍然要 $\text{pushdown}$。

我们分析上述算法中每个颜色会成为多少个线段树节点的标记。

对于任意一种颜色，它只会区间覆盖一次，所以它给线段树节点打上标记的情况只有下面两种。

1. 区间覆盖时标记。
2. 被其它颜色在区间覆盖时 $\text{pushdown}$。

前一种只会打 $O(\log n)$ 个标记，后一种的数量取决于其它颜色在区间覆盖时递归的路径，均摊下来仍然为 $O(\log n)$。

所以标记总数是 $O(m\log n)$ 的，又因为每个标记只会产生一次，然后被删除一次，对标记的修改次数为 $O(m\log n)$。

然后考虑在区间覆盖时用到的另一种数据结构该如何设计。

每一次添加新标记和清除旧标记时我们都要对这个数据结构进行单点修改，修改次数为 $O(m\log n)$。

而对这个数据结构的查询是区间求和，查询次数为 $O(q)$。

修改次数较查询次数多，于是可以用支持 $O(1)$ 修改 $O(\sqrt{m})$ 查询的分块数据结构。

此外，可以证明在线段树上 $\text{dfs}$ 清除旧标记时，递归的总次数为 $O(m\log n)$。

这样总复杂度为 $O(m\log n + q\sqrt{m})$。



$(4)$ 带查修的二维偏序问题。

**题面**

给定 $n$ 个区间 $s_i=[l_i,r_i]$，每个区间有一个权值 $a_i$。

有 $q$ 次操作，每次操作有以下两种类型

1. 给定一个区间 $[l,r]$，需要回答与 $[l,r]$ 有交的 $s_i$ 的权值之和是多少。

2. 给定一个区间 $[l,r]$ 和权值 $vl$，需要将与 $[l,r]$ 有交的 $s_i$ 的权值均加上 $vl$。

**数据范围**

$1\le n,q\le 10^5,\ 1\le l_i\le r_i\le 10^5, 1\le|vl|,|a_i|\le 10^9 $。

**分析**

对于一个区间 $[l,r]$，与它有交的区间 $[x,y]$ 一定满足 $x\le r\wedge y\ge l$，这是二维偏序，而问题又带查修操作，所以用 $\text{KD-Tree}$ 维护 $s_i$ 即可，时间复杂度为 $O(q\sqrt{n})$。

如果没有修改操作，也可以不删莫队解决。



$(5)$ 树上最小生成树。

**题面**

给定一颗 $n$ 个节点的树，现在指定树上 $m$ 个不相同节点，求使得这 $m$ 个节点连通的连通连通块的大小（节点数）最小的连通块大小是多少？有 $q$ 次修改，每次修改或增加一个指定节点，或解锁一个已经被指定了的节点，请每次修改后输出连通块大小最小为多少？

**分析**

先对树求一次 $\text{dfn}$ 序，然后让 $m$ 个指定的节点按 $\text{dfn}$ 序从小到大依次加入连通块，若当前已经加入了点 $x$，将要加入点 $y$，则让答案加上 $\text{dep}(y)$，然后减去 $\text{dep}(\text{LCA}(x,y))$。

加入完 $m$ 个节点后则减去所有节点共同的 $\text{LCA}$ 的深度，这样所计算的答案就是最小连通块的大小。

然后考虑修改。

注意到只有两个 $\text{dfn}$ 序相邻的点对答案有贡献，所以可以用线段树维护哪些点被指定，然后在 $\text{push-up}$ 时计算贡献，同时还要维护所有指定节点公共的 $\text{LCA}$ 是哪个节点。

总时间复杂度 $O((q+m)\log n)$。

**出题**

[MF游乐园](我出的题\MF游乐园.md)

**分析**

显然需要将询问离线，然后按边权从小到大加入，每加入一条边就合并两个连通块。

对每个连通块维护一颗动态开点线段树，代表当前连通块内有多少节点，然后维护这个连通块里的点在 $T_2$ 上的最小连通块的大小。

对 $begin$ 的查询就相当于是 $begin$ 所在连通块里的点在 $T_2$ 上的最小连通块的大小，这可以通过线段树合并维护。

总时间复杂度为 $O(q+n\log n)$。













