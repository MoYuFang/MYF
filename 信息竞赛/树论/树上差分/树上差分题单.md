差分这东西主要是在链上用的，而对于树结构，每个点都对应一个前缀链，所以差分也可以用在树上。

差分常见是处理对某一前缀链进行的整体操作，如前缀链上每个节点权值加上相同的数（前缀链加法）+ 单点权值查询。

像这种区间的加的操作显然经过差分后可以转化为单点加，单点查询可以转化为子树权值求和，弄完 $\text{dfn}$ 序后这一步显然可以用树状数组完成。

如果是树上路径加的话，则可以先在两端点处的前缀链各整体加一次，然后再在 $\text{LCA}$ 的前缀链上减去多加的，在 $fa(LCA)$ 的前缀链上再减去多加的。

树上差分题单：

[P5840 [COCI2015]Divljak](https://www.luogu.com.cn/problem/P5840) $\text{AC}$​ 自动机处理完后在失配树上进行操作，对于每次新加入单词，要求对树的操作是前缀链加 $1$ 且每个点只能加一次，查询操作是单点点权查询，先将此次加入单词涉及的点按 $\text{dfn}$ 排序，然后从 $\text{dfn}$ 序小的往大的处理，每次在当前点的前缀链上整体加一，然后在当前点与上一个点的 $\text{LCA}$ 的缀链上减一就可以保证每个点最多加一次了。

[P2680 [NOIP2015 提高组] 运输计划](https://www.luogu.com.cn/problem/P2680) 二分答案，把路径长大于答案的路径上的边加一（用树上差分完成），然后求出所有被所有路径覆盖过的边的最大边权，判断路径长最大的路径的路径长减去这个最大边权是否小于等于答案。时间复杂度 $O(n \log(n\cdot t))$。

[P4211 [LNOI2014]LCA](https://www.luogu.com.cn/problem/P4211) 我们首先可以把题目意思转换为：每次把询问区间 $[l,r]$ 里的点到根节点路径上的点权值（包括自己）加 $1$，最后询问 $z$ 到根节点的权值和。于是树链剖分即可。

