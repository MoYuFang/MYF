$\text{DSU on Tree}$

先写个 ```dfs``` 函数预处理出重儿子

```dsu``` 中按顺序一般是这几个步骤：

1. 递归处理完所有轻儿子，向下递归时传一个标记说明下一层递归的节点为轻儿子，跟据该标记在下一层递归结束时会把轻儿子子树的所有影响消除。
2. 递归重儿子，也向下传一个标记说明下一层递归的节点，于是下一层递归结束时就不会撤销重儿子子树影响。
3. 重新加入所有轻儿子的影响，并加入该节点的影响。
4. 回答对该节点的询问
5. 该层递归结束。如果该节点不是重儿子，撤销该节点和其所有子树的影响

注意：
1. 对于一层递归，它所有对每一个轻儿子的递归处理都是互相独立的，所以每一个轻儿子处理完后都要清理干净影响。互相独立的性质很重要。

$\text{dsu on tree}$ 算法的适用于解决树上静态问题，不支持修改，一般的题目套路是查询每颗子树的答案。

用它解题的关键是题目中要维护的信息可以通过合并节点完成，如经典的 [CF600E Lomsat gelral](https://www.luogu.com.cn/problem/CF600E) ，首先开一个全局桶用来装每个颜色出现的次数，那么对于一个节点集合，其关于主导颜色的信息就可以通过合并节点维护，每加入一个新节点可以用 $O(1)$ 更新答案。

设合并一个节点的信息用 $O(T)$，则 $\text{dsu on tree}$ 算法的时间复杂度为 $O(Tn\log n)$，其中 $n$ 是树的大小。

所以判断一道题树上静态问题是否该用 $\text{dsu on tree}$ 的关键是看这道题的答案能否通过和并节点来维护，且加入单个节点的时间复杂度 $O(T)$ 不会太大。

为了方便我们称每一时刻已合并到一起的节点集为全局节点集。

