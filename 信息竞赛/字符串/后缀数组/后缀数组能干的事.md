字符串的所有后缀的前缀就是所有子串，把握好这个关键意义就可以用后缀数组解决很多有字符串问题。

**定义**

1. $\text{sa}$ 是后缀数组，$\text{height}$ 是表征排名相邻的两个后缀的 $\text{lcp}$，$\text{rk}$ 数组表征的是某后缀的排名。
2. 设字符串 $S$ 长度为 $n$，$S$ 的以 $i$ 为左端点位置的后缀记作 $S[i:n]$，以 $i$ 为右端点位置的前缀记作 $S[1:i]$，以 $l$ 为左端点位置 $r$ 为右端点位置的子串记作 $S[l,r]$。
3. 两个后缀 $S[i:n],S[j:n]$ 的最长公共前缀记作 $\text{lcp}(i,j)$，若 $i=j$ 则 $\text{lcp}(i,j)=n-i+1$。
4. 两个字符串 $S_1,S_2$ 的最长公共前缀记为 $\text{lcp}(S_1,S_2)$。
5. 某字符串 $S$ 的长度记作 $|S|$，
6. 某字符串 $S$ 的第 $i$ 位字符记作 $S[i]$（$i$ 从 $1$ 开始）。



$(1)$ 给定长度为 $n$ 的字符串 $S$ 作为母串，有若干次询问，第 $i$ 次询问给出一个长度为 $k_i$ 的字符串 $T_i$，请你判断 $T_i$ 是否出现在 $S$ 中，若出现则求出 $T_i$ 是 $S$ 哪些后缀的前缀（提前说明若利用后缀数组则可以以 $O(1)$ 个数的变量表征这个信息），要求在线回答。

**分析**

求出 $\text{sa}$ 数组和 $\text{height}$ 数组后可以以 $O(k_i\log n)$ 回答单次询问。

回答每次询问的方法如下。

一开始模式串 $P$ 为空，我们从左到右，将 $T_i$ 的字符逐一加入到 $P$ 的末尾，故任意时刻 $P$ 都是 $T_i$ 的前缀。

设第 $j$ 次加入字符后模式串为 $P_j$，若 $P_j$ 在 $S$ 中出现，则 $S$ 中 _ 以 $P_j$ 为前缀的 _ 后缀们在 $sa$ 数组中是连续的一段，也即它们的排名是连续的一段。

不妨设这些后缀们的最小排名为 $l_j$ 最大排名为 $r_j$，则所有以 $P_j$ 为前缀的后缀的排名一定在 $[l_j,r_j]$ 内。

所以仅用 $l_j,r_j$ 两个数就能表示 $S$ 中哪些后缀以 $P_j$ 为前缀。

然后我们在给 $P$ 逐一加入字符的时候通过 $[l_j,r_j]$ 来得到 $[l_{j+1},r_{j+1}]$，这样插入 $k_i$ 次后我们就能得到以 $T_i$ 为前缀的后缀的排名区间 $[l_{k_i},r_{k_i}]$。

设我们已经加入了 $T_i$ 中的前 $j$ 个字符，有了模式串 $P_j$ 和排名区间 $[l_j,r_j]$，现在要插入第 $j+1$ 个字符 $c_{j+1}$。

我们通过在 _ 排名在 $[l_j,r_j]$ 内的 _ 后缀中分别二分出以 $P_j+c_{j+1}$ 为前缀的 _ 排名最小的 _ 以及 _ 排名最大的 _ 的后缀，它们两个的排名就分别是 $l_{j+1}$ 和 $r_{j+1}$，于是我们以 $O(\log n)$ 通过 $[l_j,r_j]$ 出了 $[l_{j+1},r_{j+1}]$。

如果求发现求不出 $[l_{j+1},r_{j+1}]$，也即 $P_j$ 在 $S$ 中出现，但 $P_j+c_j$ 不在 $S$ 中出现，那么 $T_i$ 肯定也不在 $S$ 中出现。 

因为 $T_j$ 的长度为 $k_j$，则单次回答询问的时间复杂度达到了优秀的 $O(k_j\log n)$，并且不像 $\text{hash}$ 二分一样有小概率出错，这个算法的正确性是绝对的。



$(2)$ 在 $(1)$ 的背景下，还要求回答在 $S$ 的所有子串（位置不同但字符串相同的子串算做多个）中字典序小于 $T_i$ 的子串的个数，即便 $T_i$ 没有出现在 $S$ 中。

**分析**

还是利用 $S$ 所有后缀的前缀就是所以子串这个意义，对于 $S$ 的一个后缀 $S[i:n]$，我们称 $S[i:n]$ 的前缀为 $S[i:n]$ 的导串，意思是由 $S[i:n]$ 导出的 $S$ 的子串。

设 $P_j$ 是 $T_i$ 中 _ 在 $S$ 中出现的 _ 最长前缀，$[l_j,r_j]$ 是以 $P_j$ 为前缀的后缀的排名区间。

为了方便，$\forall rk_x\in[1,n]$，我们记 $x=sa(rk_x)$。

- 若 $rk_x\in[1,l_j-1]$，则 $S[x:n]$ 的导串必定小于 $T_i$。

- 若 $rk_x\in[r_j+1,n]$，则 $S[x:n]$ 的导串必定大于 $T_i$。

-  否则 $rk_x\in[l_j,r_j]$，则 $S[x:n]$ 的导串分为两类，一类是长度大于等于 $|P_j|$ 的，一类是长度小于 $|P_j|$ 的，前一类的字典序一定大于等于 $P_j$，后一类的字典序一定小于 $P_j$。

若 $P_j=T_i$，也即 $T_i$ 在 $S$ 中出现，则我们的回答就完成了。

如果 $P_j\neq T_i$，则 $rk_x\in[l_j,r_j]$ 的 $S[x:n]$，去除前缀 $P_j$ 后的 $S[x:n]-P_j$ 一定不与 $T_i-P_j$ 相同，所以这些 $S[x:n]$ 又可以分为两类，一类是 $S[x:n]-P_j$ 小于 $T_i-P_j$ 的，一类是 $S[x:n]-P_j$ 大于 $T_i-P_j$，且这两类的排名区间可以由一个分点 $mi\in[l_j,r_j]$ 分成两个部分 $[l_j,mi]$ 和 $[mi+1,r_j]$。

那么自然，_ $rk_x\in[l_j,mi]$ 的 $S[x:n]$ 的长度大于 $|P_j|$ 的导串 _ 一定小于 $T_i$，_ $rk_x\in[mi+1,r_j]$ 的 $S[x:n]$ 的长度大于 $|P_j|$ 的导串 _ 一定大于 $T_i$。

所以我们仍然可以 $O(k_i\log n)$ 回答。 

若将问题稍微改改，认为字符串相同的子串算做一个，也可以用类似的方法解决。



$(3)$ 给定长度为 $n$ 的字符串 $S$，然后给定 $q$ 个子串 $S[l_i,r_i]$，要求给这些子串排序。

**分析**

建出 $\text{height}$ 数组的 $\text{st}$ 表后可以 $O(1)$ 回答任意两个后缀的 $\text{lcp}$，根据此可以设计出 $O(1)$ 比较两个子串大小的函数。

设现在我们要比较子串 $S[l_i,r_i]$ 和 $S[l_j,r_j]$ 的大小关系。

记 $s_1=S[l_i,r_i],\ s_2=S[l_j,r_j]$，不妨设 $r_i-l_i\le r_j-l_j$，也即 $s_1$ 长度不超过 $s_2$ 长度。

记 $len=\text{lcp}(l_i,l_j)$，分以下几种情况。

1. 若 $len<|s_1|$，则比较字符 $S[l_i+len-1]$ 与 $S[l_j+len-1]$，也就是最长公共前缀的下一位
2. 若 $len=|s_1|$，则 $s_1$ 是 $s_2$ 的前缀，显然有 $s_2$ 大于等于 $s_1$。

利用 ```sort``` 函数即可。



$(4)$ 给定长度为 $n$ 的字符串 $S$，然后给定 $a$ 个子串 $[l_i,r_i]$ 和 $b$ 个子串 $[x_i,y_i]$，分别组成可重集 $A$ 和 $B$，对每个 $B$ 中串 $[x_i,y_i]$，请你求出哪些 $A$ 中串 $[l_j,r_j]$ 以 $[x_i,y_i]$ 为前缀（下文说明这个信息能够以 $O(1)$ 个数的变量表征）。

**分析**

首先将 $A$ 中的子串按照 $(3)$ 给出的方法排序。

排序后可以发现，$\forall [x_i,y_i]\in B$，包含 $[x_i,y_i]$ 的 $A$ 中串一定是一个连续的区间，可以通过二分求出这个区间。



例题：

[P5284 [十二省联考 2019] 字符串问题](https://www.luogu.com.cn/problem/P5284) 后缀数组 + 线段树优化建图 + $\text{tarjan}$ 判环 + $\text{DAG}$ 上的 $\text{dp}$。 



$(5)$ 给定长度为 $n$ 的字符串 $S$，求 $S$ 中有多少不同的子串。

**分析**

不同的子串个数等于所有后缀的长度之和 - $\text{height}$ 数组之和。

[oiclass P4088 字符串](..\..\题面\oiclass P4088 字符串.png) 后缀数组+回滚莫队。这题极端卡常，复杂度搞到 $O(n\sqrt{n})$ 就算过了吧。



$(6)$ 在 $\text{height}$ 数组上通过并查集合并或线段树合并统计信息。

如果将 $\text{sa}$ 数组看作链表，$\text{height}$ 数组看作链表的边（称作 $h$ 边），值看作边权，一开始我们认为这个链表的每一条边都是熄灭的（相当于还未连边）。

我们按照边权从大到小点亮边，则任意时刻这个链表会分成不同的连通块，每个连通块相当于一个区间（这个区间内的后缀们的排名连续）。

设当前权值大于等于 $t$ 的 $h$ 边都已经被点亮了，任取排名为 $rk_i$ 后缀 $S[i:n]$，设 $S[i:n]$ 所在的连通块对应的区间为 $[l_{rk_i},r_{rk_i}]$，则排名在区间 $[l_{rk_i},rL_{rk_i}]$ 的的后缀们一定有一个长度为 $t$ 的公共前缀。

利用这个方法可以一边合并一边统计信息。

例题：

[P2178 [NOI2015] 品酒大会](https://www.luogu.com.cn/problem/P2178) 后缀数组 + 并查集合并

[P4384 [八省联考2018]制胡窜](https://www.luogu.com.cn/problem/P4384) 后缀数组 + 容斥 + 线段树合并

[SP1811 LCS - Longest Common Substring](https://www.luogu.com.cn/problem/SP1811) 将两个字符串用 ```#``` 拼接起来，然后跑后缀数组。将 $\text{height}$ 里的数值看作边权，用于连接两个相邻的后缀。将所有边按边权从大到小加入（用并查集合并），则当边权大于 $w$ 时的边都加入后，任意连通块内的所有后缀有一个长度为 $w$ 的公共前缀。给第一个字符串里的后缀染黑色，第二个字符串里的后缀染白色，然后在并查集合并时若发现某个连通块里既有黑色点又有白色点，则说明此时的 $w$ 就是答案。

[SP1812 LCS2 - Longest Common Substring II ](https://www.luogu.com.cn/problem/SP1812) 同上题类似，由于并不超过 10 个字符串，可以将并查集中一联通快所拥有的颜色集合状压起来。





















