### 贡献分步计算

#### $\text{CDQ}$ 分治

$\text{CDQ}$​ 分治的起源是 $\text{merge}$​ 排序，它分治时每递归到一层，都用左区间相关性质去更新在右区间里的询问，这要求了某个位置上的询问的贡献，一定只能是更小位置上的相关性质产生的，在分治的过程中每个询问的贡献不是一步完成，而是经过若干步完成（$\log n$ 步），这体现出贡献分步计算的思想。

### 特殊询问顺序

#### 莫队

莫队算法复杂度的保证在于曼和顿距离的最小生成树的权值为 $O(n\sqrt{m})$ 级别的，其中 $[1,n]$ 为点的坐标范围，$m$ 为点的个数。

#### 时间反转

对于有些带修改的数据结构问题，原来的修改顺序不好实现，但如果将顺序倒过来就容易实现。常见的例子有：

（1）给定图，修改操作只有不断删边，求每次删边后连通块的数量。求连通块一般用并查集，但并查集只支持合并、不支持分裂，所以可以将操作顺序倒过来，这样删边操作就变成加边操作。

（2）按顺序给定 $n$ 个互不相等的数，依次插入集合 $S$，定义集合 $S$ 的权值：将 $S$ 中的元素排序后得到 $a_i(1\le i\le|S|)$，权值 $f(S) = \sum_{i=1}^{|S|-1} a_i^2\oplus a_{i+1}^2$，求每次插入后的 $f(S)$。如果将操作顺序反过来，插入操作变成删除操作，用链表这一数据结构可以做到每次 $O(1)$ 删除并计算对 $f(S)$ 的改变。

#### 字典序顺序

这类问题的典型是给定一段序列，每次询问给出区间 $[l,r]$，要求根据 $[l,r]$ 这一段序列的性质回答。对于一些问题，可以将询问离线，按照 $r$ 为第一关键字，$l$ 为第二关键字排序，然后处理询问时不断让 $r$ 递增，$r$ 每递增到一个值时，回答所有右端点为 $r$ 的询问。

### 持续性操作

#### 线段树分治

线段树分治能解决的问题中有明显的时间顺序，一般是给定若干操作即每个操作持续的时间区间（比如某条边在图上出现的时间区间），然后在每个时间点处回答询问。

根据任意区间能够划分为线段树上的 $2\lceil\log n\rceil+O(1)$ 个区间，所以可以将所有持续性的操作挂在相应的节点上，然后 $\text{dfs}$ 一遍线段树来处理每个时间点上的询问，这个过程常搭配上可撤销的数据结构。

#### $\text{KD-Tree}$ 分治

与线段树分治类似，只不过时间区间变成了矩阵（或超立方体）区域。

### 带修离线

#### 带修莫队

传统莫队算法的改进。

#### 操作序列分块

若经过预处理后可以快速回答某查询，且任意修改操作对某回答的贡献可以快速计算，这时可以使用操作序列分块。

设有 $n$ 个操作，操作分修改和查询两种，若无修改操作，经过 $O(n)$ 预处理后可以 $O(1)$ 回答某次询问，单次修改对某询问的贡献可以 $O(1)$ 计算。

记分块块长为 $b$，将操作序列分块，按顺序处理每一块。

处理第 $i$ 块时，先把前 $i-1$ 块的修改操作执行完，然后预处理一遍，然后按顺序处理本块中的操作。

处理到本块中的修改操作时不修改，而是将修改操作预留下来。处理到查询操作，先通过预处理的结果 $O(1)$ 计算出答案，然后根据预留下来的修改操作调整答案。

这样每次询问至多存在 $b$ 个预留的修改操作，预处理和查询的总时间复杂度为 $O(n^2/b+nb)$，取 $b=\sqrt{n}$ 可得到最小值。



