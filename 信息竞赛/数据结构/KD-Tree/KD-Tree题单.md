[CF44G Shooting Gallery](https://www.luogu.com.cn/problem/CF44G) 给所有矩阵按 $z$ 轴值从小到大排序，按顺序处理每个矩阵。对于当前枚举到的矩阵，找到被它覆盖的最早射击且没被删除的子弹，这颗子弹一定会击中当前矩阵，然后删除这颗子弹，若找不到这样的子弹则说明这个矩阵不会被击中。用 $\text{KD-Tree}$ 完成即可。

[BZOJ4154 Generating Synergy](..\..\题面\BZOJ4154 Generating Synergy.png) 将子树的限制看做对 $\text{dfn}$ 序的一个区间，将距离限制看做深度 $dep$ 的一个区间，用 $\text{KD-Tree}$​ 支持矩阵染色和单点查询即可。

[P6349 [PA2011]Kangaroos](https://www.luogu.com.cn/problem/P6349) 对于一个区间 $[L,R]$，与它相交的区间 $[l,r]$ 必须满足 $l\le R \wedge r>L$，这是个二维偏序条件，若将左端点看作 $x$ 坐标，右端点看作 $y$ 坐标，则每个区间是二维平面上的一个点，这个偏序条件可以用矩阵来表示。将每个询问看作一个二维平面上的点，构建 $\text{KD-Tree}$，每个叶子节点对应一个询问，每个询问开一个值 $vl_i$，然后按顺序处理序列，每处理到一个元素 $[l_i,r_i]$，令 $[le,ri]=[l_i,r_i]\cap[l_{i-1},r_{i-1}]$，将所有与 $[le,ri]$ 相交的询问的 $vl_i$ 加一，所有与 $[le,ri]$ 不相交的询问的 $vl_i$ 置 $0$。所有元素处理完后，第 $i$ 个询问的答案就是 $vl_i$ 的历史最大值。上述操作包含区间加、区间覆盖，需要维护历史最大值，这是线段树可以做的，$\text{KD-Tree}$ 当然能做。时间复杂度为 $O(n\sqrt{m})$。

[P6783 [Ynoi2008] rrusq](https://www.luogu.com.cn/problem/P6783) 对所有询问按照右端点升序排序，然后从左到右枚举矩阵，每次加入一个矩阵，维护每个关键点上最晚加入的矩阵的序号 $t_i$。加入到第 $r$ 个矩阵时，对区间 $[l, r]$ 的询问相当于所有满足 $t_i\ge l$ 的点的权值。于是需要用 $\text{KD-Tree}$ 来支持区间覆盖操作，用 $O(1)-O(\sqrt{m})$ 的分块维护 $f(x)$ 数组，$f(x)$ 表示 $t_i$ 为 $x$ 的关键点的贡献。每次打标记时判断子树中是否打了标记，如果有则需要将子树里的所有旧标记清除。注意到至多有 $O(m\sqrt{n})$ 个标记，每个标记只会出现、被删除各一次，每次回答查询则需要 $O(\sqrt{m})$，总时间复杂度为 $O(n\log n + m\sqrt{n} + q\sqrt{m})$。

[P4148 简单题](https://www.luogu.com.cn/problem/P4148) 带插入的 $\text{KD-Tree}$​​，用根号分治可以做到 $O(n\sqrt{n})$。

[P7883 平面最近点对（加强加强版）](https://www.luogu.com.cn/problem/P7883) 建树时需要根据方差选轴。搜索时不要进入了下一层才开始剪枝，而是在进入前就判断需不需要剪枝，因为函数的调用会耗时。
