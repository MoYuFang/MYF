一般来说，链表的单次查询或修改，为了定位到正确的位置，会到达可怕 $O(n)$。

原因在于一步一步地跳太慢了，得考虑优化这一步，于是就有了倍增，倍增的本质实际上是对要跳的距离进行二进制拆分，通过预处理出倍增数组而将跳链的次数优化为 $O(\log n)$。

设 $nxt(j,i)$ 为节点 $i$ 向后跳 $2^j$ 个节点后的所到达的节点，则有转移 $nxt(j,i) = nxt(j-1,nxt(j-1,i))$，显然 $j$ 最大为 $\log n$ 因此 $nxt(j,i)$ 的规模是 $O(n\log n)$ 的。

根据此则在很多有跳链操作的题中可以考虑用倍增优化跳链的复杂度。

[P3509 [POI2010]ZAB-Frog](https://www.luogu.com.cn/problem/P3509) 首先用双指针计算出每个节点下一步要到达的节点，之后就是跳链的操作了。

[P5666 [CSP-S2019] 树的重心](https://www.luogu.com.cn/problem/P5666) 预处理出每个节点重儿子和次重儿子，然后用换根 $\text{dp}$ 枚举每个要删除的边，因为重儿子一定是在根节点的重链上，找重儿子的过程就相当于是在重链上向下跳，停止的条件是 $sz(v)*2 < all$，其中 $all$ 是整颗树的大小，$sz(v)$ 是子树 $v$ 大小，于是可以维护每个节点跳重链的倍增数组，在换根 $\text{dp}$ 的过程中动态维护，时间复杂度是 $O(n\log n)$。

倍增求 $\text{LCA}$ 本质上就是将跳前缀链的复杂度从 $O(n)$ 优化成 $O(\log n)$​​。

值得注意的是，如果用倍增维护跳链操作的话只能从链首增删节点，单次增 $O(\log n)$ ，单次删 $O(1)$，为从链尾增删节点要更新原来链表上每一个节点的倍增数组，复杂度炸成 $O(n\log n)$，树的重心那一题也是因为换根时只涉及到链首的增删节点，从而能实现在单次换根时以 $O(\log n)$​ 分别更新旧根与新根的倍增数组。

[P7518 [省选联考 2021 A/B 卷] 宝石](https://www.luogu.com.cn/problem/P7518) 

[P7599 [APIO2021] 雨林跳跃](https://www.luogu.com.cn/problem/P7599) 

