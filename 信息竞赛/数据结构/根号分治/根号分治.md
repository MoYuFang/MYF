#### 根号分类

给定若干数 $a_i$，并有限制 $\sum a_i=n$，则数值不同的 $a_i$ 最多有 $O(\sqrt{n})$，有些题目中数值相同的数可以一并处理，因为最多有 $O(\sqrt{n})$ 个数不同，故只用处理 $O(\sqrt{n})$ 次。

根号分治还有一个常见的用法是分将数分成两类，一类是数值不超过 $O(\sqrt{n})$ 的数，一类是数值超过 $O(\sqrt{n})$ 的数，两类分开处理。对于第一类，枚举数值，然后分别处理，对于第二类，枚举每个数，然后分别处理，显然因为第一类中的数值不超过 $O(\sqrt n)$，第二类中数的个数不超过 $O(\sqrt{n})$，故两种枚举的次数均为 $O(\sqrt{n})$​。

#### 二分图的根号分治

设 $a,b$ 两部分点组成的二分图上有 $m$ 条边，需要将每条边分配给其中一端，使得每个点负责的边数不超过一个不太大的数 $B$。

利用根号分治，仅当 $a$ 部分中某点的度数大于 $\sqrt{m}$，让这点负责与它相连的所有边，剩下的边全由 $b$ 部分的点负责。

因为 $b$ 部分的每个点，至多与 $\sqrt{m}$ 个度数大于 $\sqrt{m}$ 的 $a$ 部分的点相连，所以 $b$ 部分的点负责的边数不超过 $\sqrt{m}$。

这种分配方法可使 $B\le \sqrt{m}$。

也可以这样，每条边分配给度数小的那条条边去，如果度数相同则分配给已负责边数小的那个端点。

#### 根号插入

对于二叉树，如果只进行插入操作而不维护平衡，那么树高很容易卡成 $O(n)$，但如果每隔一段时间就将整颗树重构则可使复杂度降低。

设查询的次数与插入的次数均为 $n$，每次插入数时不真正插入，而是将数预留起来，当预留的数达到 $b$ 个时就对整颗树包括预留的数进行重构，每次回答查询时还要遍历一遍预留的数。

则重构的时间复杂度为 $O(n^2/b)$，查询的时间复杂度为 $O(n(\log n+b))$，当 $b=\sqrt{n}$ 时总时间复杂度最小，为 $O(n\sqrt{n})$​。

虽然这个方法对于二叉树而言时间复杂度劣于平衡树的 $O(n\log n)$，但若将它应用到 $\text{KD-Tree}$ 上情况就不一样了。

以维护二维点的 $\text{KD-Tree}$ 为例，设有 $n$ 次插入和 $n$ 次对矩阵的查询，单次查询是 $O(\sqrt{n})$。

插入时，为了保持平衡，则需要用替罪羊树的思想，维护一个平衡因子，当某颗子树失衡时就重构这颗子树，这样的实现常数较大。

如果用根号分治，设一个阈值 $b$，每次插入时不真正插入，而是将插入的点预留起来，达到 $b$ 个时再重构整颗 $\text{KD-Tree}$。

这样重构的次数是 $n/b$，每次重构的时间复杂度为 $O(n\log n)$，每次查询的复杂度为 $O(\sqrt{n}+b)$，总时间复杂度为 $O(n^2\log n/b+n(\sqrt{n}+b))$，当 $b=\sqrt{n\log n}$ 时有最小值 $O(n\sqrt{n\log n})$。

如果想要去掉 $\log n$，可以用不同的重构策略。

维护两颗 $\text{KD-Tree}$ $T_0$ 和 $T_1$，设一个阈值 $b$，每次插入时预留，积攒到 $\sqrt{n}$ 时就将预留值与 $T_0$ 合并，当 $T_0$ 的大小达到 $b$ 时就将 $T_0$ 合并到 $T_1$，每次可并用重构，每次查询时要在 $T_0$、 $T_1$ 上查询和遍历预留的点。 

这样重构 $T_0$ 的次数是 $\sqrt{n}$，每次重构 $O(b\log n)$，重构 $T_1$ 的次数是 $n/b$，每次重构 $O(n\log n)$，每次查询为 $O(\sqrt{n})$，总时间复杂度为 $O(b\sqrt{n}\log n+n^2\log n/b+n\sqrt{n})$，取 $b=n^{3/4}$ 时有最小值 $O(n^{5/4}\log n+n\sqrt{n})=O(n\sqrt{n})$​。

#### 题单

[oiclass P4009 给国的语言](..\..\题面\oiclass P4009 给国的语言.png) 将长度相同的单词插入到同一个 $\text{AC}$ 自动机，因为最多有 $\sqrt{\sum t}=\sqrt{n}$ 种长度不同的字符串，所以 $\text{AC}$ 自动机的个数至多为 $\sqrt{n}$。在每一个 $\text{AC}$ 自动机上以 $O(n)$ 跑一遍原串，这样只有到达接收状态才需要更新答案，每到一个状态不用跳失配指针，总时间复杂度为 $O(n\sqrt{n})$。

[P5072 [Ynoi2015] 盼君勿忘](https://www.luogu.com.cn/problem/P5072) 莫队+光速幂+链表+根号分治。

[P6189 [NOI Online #1 入门组] 跑步](https://www.luogu.com.cn/problem/P6189)

此题要求在没有 $\text{NTT}$ 模数的情况下计算第 $n$ 项分拆数。

不难发现，可以用类似完全背包的 $\text{DP}$ 来计算分拆数，但复杂度是 $O(n^2)$ 的，无法通过。

考虑根号分治，记 $m=\sqrt{n}$。当使用 $k$ 进行拆分时：

$k<m$ 时暴力完全背包。

$k\geq m$ 时，采用如下 $\text{DP}$：

$g[i][j]$ 表示用了 $i$ 个 （ $\ge m$ 的数 ），和为 $j$ 的方案数。

边界为 $g[0][0]=1$ ，转移为 $g[i][j]=g[i-1][j-m]+g[i][j-i]$

其中前者 $g[i-1][j-m]$表示加入一个 $m$ ，后者表示将现在的整个序列整体 $+1$。

不难发现这样生成的一定是有序序列，且每种序列生成方法唯一。

不难发现第一维不超过 $O(n/m)=O(\sqrt{n})$。

于是，我们用 $O(n\sqrt{n})$ 的复杂度算出了 $F,G$ ，然后卷积即可得到分拆数。本题中只需要一个系数，故可线性求得。

[P4148 简单题](https://www.luogu.com.cn/problem/P4148) 带插入的 $\text{KD-Tree}$。

[Be Surrounded](..\..\题面\BeSurrounded.png) 注意到每个点的度数之和为 $O(2n)$，设点 $u$ 的度数为 $d_u$。

定义一个点称作大点仅当它的度数 $>\sqrt{n}$，反之称作小点。

对每个点维护它自身的权值，对每个大点维护其周围的点的权值和。

修改时，若修改的是小点，除了修改自身权值外，还要枚举周围的大点并更新大点，若修改的是大点则修改自身权值和就行，单次复杂度 $O(\sqrt{n})$。

查询时，若查询的是小点，则枚举周围的点并求答案，若查询的是大点则直接回答，单次复杂度 $O(\sqrt{n})$。

[P3396 哈希冲突](https://www.luogu.com.cn/problem/P3396) 

[P5309 [Ynoi2011] 初始化](https://www.luogu.com.cn/problem/P5309) 当 $x>\sqrt{n}$ 时直接暴力修改，用 $O(1)$ 修改 $O(\sqrt{n})$ 查询的分块数据结构维护。当 $x\le \sqrt{n}$ 时，对每个 $x$ 维护一个周期内的值 $vl_x(*)$，对 $vl_x(*)$ 做前缀和得到 $pre_x(*)$，单次修改维护 $pre_x(*)$ 花费 $O(\sqrt{n})$，利用 $pre_x(*)$ 就可以 $O(1)$ 得到 $x$ 对某次询问的贡献，总时间复杂度为 $(n\sqrt{n})$。注意卡常，修改时维护分块和 $pre_x(*)$ 只用到加法，这是不要直接取模，而是加完后判断是否大于等于模数，若是则减去模数。回答查询时涉及到乘法和加法，乘法乘出来的数最大为 $10^9\times n$，加法最多做 $2\sqrt{n}$，于是 $10^9\times n\times 2\sqrt{n}\le 1.8\times10^{18}$，可以用 ```long long```  存下中间计算的结果，不取模，等到输出答案时再取模。

[P5397 [Ynoi2018] 天降之物](https://www.luogu.com.cn/problem/P5397) 

[CF1039D You Are Given a Tree](https://www.luogu.com.cn/problem/CF1039D) 

[P10542 [THUPC 2024 决赛] RPG](https://www.luogu.com.cn/training/566110#problems)

记 $f_i$ 表示前 $i$ 人已经决策了，且第 $i$ 个人攻击后的最大伤害。
$$
f_i=d_{b_i}+\max\begin{cases}f_j+e_{a_{j+1},b_i}&(j<i-1)\\f_j&(j<i)\end{cases}
$$
$m$ 个暴击规则可以看作是 $a,b$ 二分图（合并了同值）上的 $m$ 条边。

主要考虑转移中的第一行，实现转移的方式有两种，一种是，算出了 $f_{i-2}$，然后 从 $a$ 端 $a_{i-1}$ 对应的点出发，去刷新 $b$ 端若干点，另一种是在计算 $f_i$ 时，以 $b$ 端上 $b_i$ 对应的点为终点，去收集 $a$ 端上若干点的贡献。

于是，优化转移的任务就变为，在 $a,b$ 二分图上，将 $m$ 条边分配给 $a$ 端或 $b$ 端，要求是不管 $a$ 端还是 $b$ 端，每个点负责的边的个数都不太大，记为不超过 $B$。

显然，根号分治可使 $B=\sqrt{m}$，总时间复杂度是 $O(n\sqrt{m})$。

显然，可以分别统计 $a,b$ 中某点在原 $\set{a_i},\set{b_i}$ 序列中出现的次数 $cnt$，$m$ 条边根据哪个端点的 $cnt$ 更小去分配，这样会优化一点常数。
