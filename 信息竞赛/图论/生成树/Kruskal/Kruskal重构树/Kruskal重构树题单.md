[P4197 Peaks](https://www.luogu.com.cn/problem/P4197) 

[P4768 [NOI2018] 归程](https://www.luogu.com.cn/problem/P4768) 

[nkoj P8438路径权值](http://oi.nks.edu.cn/zh/Problem/Details/8438) 直接求每个点的贡献高达 $O(n^2)$，但因为边数只有 $O(n)$，于是考虑每条边对哪些点有贡献。先求出最大生成树的 $\text{Kruskal}$ 重构树，重构树上非叶子节点任意左子树叶子节点与任意右子树叶子节点组成的点对的路径都经过该非叶子节点，且因为重构树是小根堆，所以这些路径中有贡献的边就是该非叶子节点对应的边，贡献可以通过区间加完成，又考虑到是在所有加操作完成后才进行每个叶子节点的查询，于是可以使用标记永久化的技巧，复杂度 $O(n\log n + n)$，其中 $O(n\log n)$ 还是排序。

[nkoj P8437 删边](http://oi.nks.edu.cn/zh/Problem/Details/8437) 建立最大生成树的 $\text{Kruskal}$ 重构树，然后 $\text{dfs}$ 重构树求出 $\text{dfn}$ 序，对于每次询问，求节点集两两之间的 $\text{LCA}$ 复杂度不够优秀，考虑到 $\text{dfn}$ 序越近的点对 $\text{LCA}$ 越深（对应的边权也越大），于是将节点集按 $\text{dfn}$ 排序后求相邻两点间的 $\text{LCA}$ 即可。

[P6765 [APIO2020]交换城市](https://www.luogu.com.cn/problem/P6765) 改造一些传统的 Kruskal 重构树，去掉二叉树的限制。对于某个连通块，如果这个连通块是一条链，那么从任意两点出发的车不可能不相遇，如果这个连通块有度数超过三的点，那么从任意两点出发的车一定能互相到达。根据此改造 Kruskal 重构树和 Union-Find。加入某条边时，如果两端点在同一连通块内，若这一连通块原先是链，加完边后一定不是链，这时新建节点，在 Kruskal 重构树上将所有链上的点连向新点，新点权值为加的边的权值。如果两端点在不同连通块，若两个连通块都是链，且加入新边后还是链，则合并链，但不新建节点，否则加边后不再是链，需要在 Kruskal 重构树上新建节点。若两个连通块其中之一不是链，也需要新建节点。总时间复杂度 $O((N+Q)\log N)$。
