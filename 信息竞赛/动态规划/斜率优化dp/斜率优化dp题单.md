[P5468 [NOI2019] 回家路线](https://www.luogu.com.cn/problem/P5468) 以列车作为状态，先写出状态转移方程，然后发现可以用斜率优化。对每个节点开一个 ```vector``` 维护下凸包。用桶排序将所有 $p_i$ 和 $q_i$ 排个序，当 $q_i = p_j$ 时 $q_i$ 在前，然后将这 $2m$ 个数看作 $2m$ 个事件，当碰到 $p_i$ 事件就求出 $dp(i)$，碰到 $q_i$ 事件则将 $dp(i)$ 加入凸包。

[P2305 [NOI2014] 购票](https://www.luogu.com.cn/problem/P2305) 设第 $u$ 个节点的深度为 $d_u$，$f(u)$ 为 $u$ 到根的最小花费，$A_u$ 是 $u$ 的祖先集，很容易想到 $\text{dp}$
$$
f(u)=\min_{v\in A_u\wedge d_u-d_v<l_u}\{-d_vp_u+f(v)\}+d_up_u+q_u
$$
显然，将 $-d_v$ 看作斜率、$f(v)$ 看作截距，则 $-d_v$ 是单减的，可以通过维护上凸包来优化 $\text{dp}$。

每次计算 $f(u)$ 时，首先二分出最佳决策的 $-d_v$，然后判断 $d_u-d_v$ 是否小于等于 $l_u$，如果是则答案就求出来了，如果不是，则再二分出满足 $l_u$ 限制的最小的 $-d_v$ 并计算答案。

上面的做法是对于链的情况的，如果对于树，则需要设计可撤销单调栈，均摊弹出的方法复杂度会假，可以每次入栈时先二分出新的 $top$ 是什么，然后只修改 $top$ 上的斜率，这样回撤时就只用回撤一个修改和回撤 $top$。

总时间复杂度 $O(n\log n)$。