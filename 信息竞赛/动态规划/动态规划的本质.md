动态规划从本质来讲是算法设计思想，设计解决复杂**决策**问题的思想。

在动态规划中决策是精髓，有**决策**才有动态规划，才有**状态**。

我们以一个动态规划中最经典的背包问题来分析动态规划的思想：



**背包问题**

给定 $n$ 物品，每个第 $i$ 个物品有价值 $v_i$ 重量 $w_i$，现在我们有一个背包，这个背包有一个总重 $W$，它能装下一些物品，但是这些物品的总重量不能超过 $W$， 我们想要设计一个装物品的方法，使得背包里的物品的总价值 $V$ 最大。



$f(i,x)$ 



**分析**

首先，这是一个**决策**问题，我们要决策的是将哪些物品放入背包，哪些物品不放入背包，以使物品的总价值最大。

明白了决策后，我们思考每一种决策会影响什么东西，这里装入物品与否影响的东西只有两个，一个是背包里的物品的总重为多少，一个是背包里的物品的总价值为多少。

这两个被决策所影响的东西叫做**状态**，它代表了一种决策所含有的我们关注的所有信息，因为我们不关注背包里的物品是哪些，只有总重和总价值才能影响我们的决策。

其次，这里有 $n$ 个物品，如果我们一次就决定好哪些物品放进背包，哪些物品不放进背包，那这样的决策也太复杂了，我们得想办法降低决策的复杂度。

方法是分而治之的思想，我们可以按顺序处理每个物品，对每个物品单独决策是否放入背包，这样一次决策的复杂度也就降了下来。

因为我们是按顺序决策每个物品，不同物品的决策相当于不同阶段，我们还要有第三个状态来表达我们现在决策到了第几个物品，这个状态就是阶段。

真正的算法从以下开始。

设 $f(i,x)$ 表示按顺序决策时，已经决策了前 $i$ 个物品（有的物品被决策放入，有的不放入），且前 $i$ 个物品的总重为 $x$ 时，背包里物品总价值的**最大值**（范围是 $1\le i\le n,\ 0\le x\le W$）。

这里的 $f(i,x)$，包含了先前提到的三个状态，$i$ 代表的是阶段状态，即处理到了第几个物品，$x$ 代表的是当前背包内的物品总重状态，$f$ 代表的是物品总价值的状态。

光设计了 $f(i,x)$，还不行，我们还要想办法去求出它。

求出它的方法就是**状态转移方程**。

设当前已经到了决定第 $i$ 个物品去留的阶段，当前背包里的物品总重是 $x$。

则 $f(i,x)$ 可由以下**递推**公式求出。
$$
f(i,x)=\max\left\{\begin{aligned}&f(i-1,x)\\&f(i-1,x-w_i)+v_i &(x\ge w_i)\end{aligned}\right.
$$
什么意思？

实际上那个 $\max$ 干的事就是决策。

对于当前的第 $i$ 个物品，我们只有两种决策。

- 第一种是不放入背包，对应的是转移方程里的第一行，因为不放入物品，所以背包的总重量和总价值都不变，$f(i,x)$ 从 $f(i-1,x)$ 转移来。

- 第二种是放入背包，对应的是转移方程里的第二行，因为放入了第 $i$ 个物品，所以背包的重量加了 $w_i$，价值加了 $v_i$，又因为 $f(i,x)$ 的重量是 $x$，所以之前的重量必须是 $x-w_i$，所以 $f(i,x)$ 从 $f(i-1,x-w_i)+v_i$ 转移来。

那么两种决策哪个更好呢？

我们要使背包的总价值最大，所以用取 $\max$ 方法来决定使用那种决策。

如果 $f(i-1,x)$ 更大则选择将第 $i$ 个物品丢弃，这样 $f(i,x)$ 就等于 $f(i-1,x)$。

如果 $f(i-1,x-w_i)+v_i$ 更大则选择将第 $i$ 放入背包，这样 $f(i,x)$ 就等于 $f(i-1,x-w_i)+v_i$。

为什么这样是对的？

因为所有决策我们都做了一遍，且取出了最优的方案，当然是正确的。

正确性的详细证明要用到最优子结构之类的知识，这里不详细解释，可以在算法笔记中找到，不过这不是动态规划关注的东西，因为熟悉动态规划后很容易看出动态规划的正确性。

我们关注的是如何求出
$$
\max_{1\le x\le W}\{f(n,x)\}
$$
这个就是答案。

转移方程的使用方法是**递推**。

在转移方程中我们先要求出 $f(i-1,x),\ f(i-1,x-w_i)+v_i$，然后才能求出 $f(i,x)$。

但求出 $f(i-1, x),\ f(i-1,x-w_i)+v_i$ 又需要先求出 $f(i-2, x),f(i-2,x-w_{i-1})+v_{i-1}$ 和 $f(i-2,x-w_i)+v_i,f(i-2,x-w_i-w_{i-1})+v_i+v_{i-1}$。

这个递推方程会不断递推，但总不能递推无穷次吧？不然程序怎么跑得动。

所以我们要定义**边界条件**，意思是递推到某一步的时候就不用再继续递推了，因为此时决策已经简单到不再需要状态转移方程（也就是上面的递推公式）来求出了，我们可以直接知道答案。

比如，计算 $f(1,w_1)$ 和 $f(1,0)$，这显然只是对第 $1$ 个物品的，我们直接算就行了。
$$
f(1,w_1)=v_1,\ f(1,0)=0
$$
但是还有其它一些不可能的情况，也就是当 $x\neq w_1$ 和 $x\neq 0$ 时 $f(1,x)$ 不存在，第 $1$ 物品放不放入就只能产生 $f(1,w_1)$ 和 $f(1,0)$ 两种状态.

所以我们定义当 $x\neq w_1$ 和 $x\neq 0$ 时，$f(1,x)=-\infty$，这个 $-\infty$ 代表不存在，程序实现中没有负无穷，但可以用一个充分小的负数代替，比如 $-10^9$。

于是完整的边界条件应该是
$$
f(1,w_1)=v_1,\ f(1,0)=0\\
f(1,x)=-\infty\quad(x\neq 0\wedge x\neq w_1)
$$
其中 $\wedge$ 符号是“与“、”且“、”和“ 的意思。

**决策、状态、状态转移方程、边界条件** 四步走完后，我们就算设计好了一个动态规化的算法了。

以下是程序实现和讲解。

```cpp
#include <iostream>
using namespace std;

const int maxn = 10000;
const int maxw = 10000;
const int ninf = -1e9;//-10的9次方，用来代表负无穷

int 
    v[maxn],
	w[maxn],
    f[maxn][maxw];

int main(){
    
    int n, W;
    cin >> n >> W;
    
    
    for(int i = 1; i <= n; ++i){
        cin >> v[i] >> w[i];
    }
    
    //边界条件
    f[1][0] = 0; f[1][w[1]] = v[1];
    for(int x = 0; x <= W; ++x){
        if (x != 0 && x != w[1]){
            f[1][x] = ninf;
        }
    }
    
    for(int i = 2; i <= n; ++i){
        for(int x = 0; x <= W; ++x){
            if (x >= w[i]){
                f[i][x] = ninf;
                
                //状态转移方程
                if (f[i-1][x] > ninf) //要判断一下上一个状态是否存在
                    f[i][x] = max(f[i][x], f[i-1][x]);
                if (f[i-x][x-w[i]] > ninf)
                	f[i][x] = max(f[i][x], f[i-1][x-w[i]]+v[i])
            }
        }
    }
    
    int answer = ninf;
    for(int x = 1; x <= W; ++x){
        if (f[n][x] > answer) answer = f[n][x];
    }
    
    cout << answer;
}



```





















