$\text{dp}$ 的优化有两种套路，一种是优化决策的速度，一种是转变决策方式。

前者指利用数据结构或算法技巧优化决策的复杂度，如前缀和优化、单调队列优化、$\text{st}$ 表优化、树状数组优化、线段树优化、斜率优化、WQS 优化等等。

后者指通过对问题进一步的分析和找规律，设计一个新的 $\text{dp}$，新的 $\text{dp}$ 或者排除一些无效决策，使得转移的复杂度降低，或者变成了容易用前者优化的形式。

第一种优化方式设计到各种具体的数据结构或 $\text{dp}$ 优化算法，讨论它不是本文该做的，本文着重于分析和总结第二钟优化方式。

### 减少无用决策

[P6095 [JSOI2015]串分割](https://www.luogu.com.cn/problem/P6095) 分析得到只用枚举前 $k$ 个位置进行 $\text{dp}$ 即可，于是能减少无用决策。

[oiclass P3676 服务](http://oiclass.com/problem.php?cid=1729&pid=2) $\text{Floyd}$ 后 $\text{dp}$，朴素的 $\text{dp}$ 是设 $f(i,a,b,c)$ 表示处理完了前 $i$ 个需求，且三名员工分别在 $a,b,c$ 处的最小花费，但这样转移是 $O(n^3\cdot L)$ 过不了，考虑如何优化 $\text{dp}$，思考后发现实际上其中一名员工的位置是已经确定了的，原 $\text{dp}$​ 浪费了的一维，可以优化掉这一维。

### 逆向思维

逆向思维也称时间倒流，这在数据结构题当中是常见的技巧，但这种技巧也可以应用到 $\text{dp}$ 题当中。

[P7516 [省选联考 2021 A/B 卷] 图函数](https://www.luogu.com.cn/problem/P7516) 首先可以观察到，对于每个 $u$，若一个 $v(v< u)$ 没有被删除（不对 $cnt$）有贡献，则 $v$ 存不存在对以后的点是否会被删除没有影响，这是因为若 $v$ 不在 $u$ 的强连通分量里，则 $v$ 不会影响以后的点与 $u$ 的强连通性。

故对于 $u$​，$v(v<u)$​ 能够被删除当且仅当只使用 $[v,n]$ 里的点， $u,v$​​ 能够互相到达。

对于一个边集 $G$，设 $a_G(u,v)$ 表示 $u$ 与 $v$ 是否能只使用 $[v,n]$ 里的点互相到达。

原来的问题是不断删边，对每个边集 $G_i$ （包含 $[i,m]$ 里的边），求出所有满足 $a_{G_i}(u,v)$的点对的个数，不妨将时间轴倒过来，变成一个不断加边的过程，而加边只可能会使某些 $a_{G_i}(u,v)=0$ 的点对变为 $a_{G_i}(u,v)=1$，之后 $a_{G_i}(u,v)$ 就一直等于 $1$​。所以可以求出使每个点对 $u,v$ 满足 $a_{G_i}(u,v)=1$ 的最小的 $i$，于是对于 $1\le j\le i$，一定有 $a_{G_j}(u,v)=1$​，记这样的 $i$ 为 $f(u,v)$。

然后就用与 $\text{Floyd}$ 类似方法 $\text{dp}$ 出  $f(u, v)$。

```cpp
for(re int i = n; i >= 1; --i){
    _rfor(j, i+1, n) _rfor(k, i+1, n){
        f[i][j] = max(f[i][j], min(f[i][k], f[k][j]));
        f[j][i] = max(f[j][i], min(f[j][k], f[k][i]));
    }
}
```

### 增加决策量以减少状态量

与用空间换时间的思想类似，某些 $\text{dp}$ 方程中，可以通过增加决策的数量以减少状态的数量，这样在新的 $\text{dp}$ 方程中，状态总数虽减小了，但单次转移的复杂度会升高，相当于是用时间换空间。但是若新的 $\text{dp}$ 方程能用数据结构及 $\text{dp}$ 优化算法优化决策速度，这样就达到了既优化了空间又优化了时间的目的。

[P7969 [KSN2021] Self Defence](https://www.luogu.com.cn/problem/P7969) 这一题就非常的典型，先增加决策量以减少状态量，然后用前缀和优化决策，使得空间和时间同时被优化，详见[题解](P7969 [KSN2021] Self Defence\P7969 [KSN2021] Self Defence.md)。

[oiclass P3954 直线相交](..\..\题面\oiclass P3954 直线相交.png) 平面上的棍子可以分成若干簇，每簇棍子都是相互平行的，然后不同簇的棍子一定能相交，我们按顺序考虑每一簇棍子。

首先可以设计出一个 $O(n^2m)$ 的 $\text{dp}$，设 $f(i,j,k)$ 表示已经用了前 $i$ 根棍子，最后 $j$ 个棍子在同一簇，是否能有 $k$ 个交点。

转移是
$$
\begin{aligned}
f(i,j,k)=f(i-1,j-1,k-(i-j))\\
f(i,1,k)=\mathrm{OR}_{j=1}^{i-1}f(i-1,j,k-i)
\end{aligned}
$$
第一行代表将第 $i$ 个棍子加入这最后一簇棍子，于是产生  $(i-1)-(j-1)=i-j$ 个交点。

第二行代表让第 $i$ 个棍子独自成一簇棍子，不管之前的一簇棍子有多是根，都会产生 $i-1$ 个交点。

时空复杂度都是 $O(n^2m+q)$ 的，无法通过。

考虑增加决策量以减少状态量，顺便用一点逆向思维，我们不去计算产生了多少可交点，我们去计算少相交了多少交点（总数为 $n$ 的棍子最多产生 $n(n-1)/2$ 个交点，但一簇平行的 $l$ 个棍子会使交点数量减少 $l(l-1)/2$）。

设 $f(i,k)$ 表示使用了 $i$ 个棍子，有 $k$ 个点被少相交了。

转移是
$$
f(i,k)=\mathrm{OR}_{j=1}^{i}f(i-j,k-j(j-1)/2)
$$
 相当于枚举新的一簇棍子有多少根。

于是 $x$ 根棍子是否能产生 $y$ 个交点就相当于 $f(x,x(x-1)/2-y)$ 是否为 true。

空间复杂度降为了 $O(nm)$，但时间复杂度仍然是 $O(n^2m)$，可以用 ```bitset``` 优化使得空间复杂度降为 $O(n^2m/w)$ 其中 $w$ 为机器位长（一般都是 $64$），但依然不能通过。

看起来是难以优化了，原因在于我们设计的函数 $f$ 的值域只有 true 和 false，所能容纳的信息太少了，优化决策速度也不成功。

根据我们的转移方程可以发现若 $f(i,k)$ 为 true，则 $f(i+1,k)$ 一定为 true，也就是说只要固定了 $k$，则 $f(*,k)$ 一定只有两段，前面的一段全 false，后面的一段全 true，这启发我们设计如下方程。

设 $g(k)$ 表示使得 $f(i,k)$ 为 true 的最小的 $i$ 是多少，相当于使得少相交 $k$ 个点时至少用的棍子数为多少。

转移是
$$
g(k)=\min_{j=1}^{N}\{j+g(i-j(j-1)/2)\}
$$
于是 $x$ 根棍子能产生 $y$ 个交点的充要条件就是 $g(x(x-1)/2-y)\le x$。

空间复杂度为 $O(m)$ 时间复杂度为 $O(nm)$，可以通过。

[SYSU20230902-E.Yet Another Interval Graph Problem](..\..\题面\SYSU20230902-E.Yet Another Interval Graph Problem.png) 离散化后，将区间们以左端点为第一关键字、右端点为第二关键字从小到大排序，一个 naive 的 $O(N^3)$ dp 是一个一个区间的决策是否删除，即设 $f_{i,j,k}$ 表示处理了前 $i$ 个区间，最右的端点的坐标为 $j$，当前连通块的大小为 $k$ 时的最小被删区间的权值之和，思考一会后发现，用滚动数组和线段树优化 $\text{dp}$ 的方法没法将复杂度降低。

这个 $\text{dp}$ 差的原因在于一个一个区间地决策就必然带上 $k$ 这一维，得改造 dp 去掉这一维。

设 $f_x$ 表示处理过的区间的右端点坐标不超过 $x$ 时，未被删除的区间的权值的最大值之和，$h(a,b)$ 表示在 $[a,b]$ 之内的区间们组成不超过 $k$ 大小的连通块时最大的权值之和。

显然有
$$
f_x=\max_{0\le a<x}\{f_a+h(a,x)\}
$$
然而 $h$ 数组并不好求，接下来是神之一笔。

设 $g(a,b)$ 表示在 $[a,b]$ 内前 $K$ 大的区间的权值之和，则
$$
f_x=\max_{0\le a<x}\{f_a+h(a,x)\}
$$
$g(a,b)$ 可以通过排序和二叉堆维护前 $K$ 大的权值之和的方法以 $O(N^2\log K)$ 求出。



### 贡献维度转换

贡献维度转换的思想可以参考 [贡献维度转换]()，这个思想在 $\text{OI}$ 中的组合计数、$\text{dp}$、概率期望计算中也有广泛的应用。

[P7324 [WC2021] 表达式求值](https://www.luogu.com.cn/problem/P7324) 首先建表达式树，方法是先用栈处理每个左括号对应右括号的位置，然后利用这个信息递归建树。我们将这颗树看作选拔赛，它的作用是选拔出有贡献的数。

不管有没有问号，对于第 $i$ 列数 $A_0[i],A_1[i],...,A_{m-1}[i]$，我们都可以通过一个 $\text{dp}$ 计算出对这一列中的第 $j$ 个数 $A_j[i]$ 经过选拔后胜出的次数，然后就可以计算 $A_j[i]$ 对答案的贡献。通过这个方法，总时间复杂度为 $O(nmT)$，其中 $T$ 为表达式树的节点树，不能通过。

这时我们就要用到贡献维度转换的思想了，我们不去计算每次选拔赛中是谁胜出，而去计算每个数有多少次胜出。

对于一列数 $A_0[i],A_1[i],...,A_{m-1}[i]$，影响它们各自胜出次数的因素只是它们之间的相对顺序，所以可以从这一点入手。直接枚举排列最终复杂度为 $O(m!T)$，仍然不能通过，还需要再优化。

再仔细分析一下，影响第 $j$ 个数 $A_j[i]$ 胜出次数的只是哪些数 $A_k[i]$ 小于它，哪些数 $A_k[i]$ 大于它，这让我们往枚举集合的方向思考。

设有 $\text{dp}$ 函数 $f_s(u,0/1)$，钦定集合 $s\sube U=\{0,1,..,m-1\}$，且 $U-s$ 中元素对应的数对应均大于 $s$ 中元素对应的数，当前在表达树上的节点 $u$，且子树 $u$ 中是 （$s$ 其中之一元素胜出的方案数）/（ $U-s$ 其中之一胜出的方案数）。

若 $u$ 对应的操作符是 ```<```，则有转移
$$
\begin{aligned}
&f_s(u,0)=f_s(L_u,0)\cdot f_s(R_u,0)+f_s(L_u,0)\cdot f_s(R_u,1)+f_s(L_u,1)\cdot f_s(R_u,0)\\
&f_s(u,1)=f_s(L_u,1)\cdot f_s(R_u,1)
\end{aligned}
$$
若 $u$ 对应的操作符是 ```>```，则有转移
$$
\begin{aligned}
&f_s(u,1)=f_s(L_u,1)\cdot f_s(R_u,1)+f_s(L_u,0)\cdot f_s(R_u,1)+f_s(L_u,1)\cdot f_s(R_u,0)\\
&f_s(u,0)=f_s(L_u,0)\cdot f_s(R_u,0)
\end{aligned}
$$
若 $u$ 对应的操作符是```?```，则相当于上面两种转移累加起来，合并同类项后效果就是
$$
\begin{aligned}
f_s(u,1)=f_s(u,0)=(f_s(L_u,0)+f_s(L_u,1))\cdot(f_s(R_u,0)+f_s(R_u,1))\\

\end{aligned}
$$
设 $rt$ 是表达式树的根节点，对于第 $i$ 列中第 $j$ 个数 $A_j[i]$，第 $i$ 中小于 $A_j[i]$ 的数的集合是 $s$，则通过容斥可以知道 $A_j[i]$ 最终胜出的次数是 $f_s(rt,1)-f_{s\cup\{j\}}(rt,1)$。

若同一列中存在两个数 $A_j[i]=A_k[i]$ 则将 $j$ 与 $k$ 之间的大小关系也纳入比较，这样就不会算重。

### 其它

[P3349 [ZJOI2016]小星星](https://www.luogu.com.cn/problem/P3349) 通过容斥技巧优化掉子集枚举，详见题解区。

