[oiclass P3676 服务](..\..\题面\oiclass P3676 服务.png) $\text{Floyd}$ 后 $\text{dp}$，朴素的 $\text{dp}$ 是设 $f(i,a,b,c)$ 表示处理完了前 $i$ 个需求，且三名员工分别在 $a,b,c$ 处的最小花费，但这样转移是 $O(n^3\cdot L)$ 过不了，考虑如何优化 $\text{dp}$，思考后发现实际上其中一名员工的位置是已经确定了的，原 $\text{dp}$ 浪费了的一维，可以优化掉这一维。

[P5664 [CSP-S2019] Emiya 家今天的饭](https://www.luogu.com.cn/problem/P5664)

[oiclass P3954 直线相交](..\..\题面\oiclass P3954 直线相交.png) 

[P7444 「EZEC-7」猜排列](https://www.luogu.com.cn/problem/P7444) 

[P7969 [KSN2021] Self Defence](https://www.luogu.com.cn/problem/P7969) 

[P7324 [WC2021] 表达式求值](https://www.luogu.com.cn/problem/P7324) 首先建表达式树，方法是先用栈处理每个左括号对应右括号的位置，然后利用这个信息递归建树。我们将这颗树看作选拔赛，它的作用是选拔出有贡献的数。

不管有没有问号，对于第 $i$ 列数 $A_0[i],A_1[i],...,A_{m-1}[i]$，我们都可以通过一个 $\text{dp}$ 计算出对这一列中的第 $j$ 个数 $A_j[i]$ 经过选拔后胜出的次数，然后就可以计算 $A_j[i]$ 对答案的贡献。通过这个方法，总时间复杂度为 $O(nmT)$，其中 $T$ 为表达式树的节点树，不够优秀。

进一步考虑如何去除冗余计算，可以注意到对于一列数 $A_0[i],A_1[i],...,A_{m-1}[i]$，影响它们各自胜出次数的因素只是它们之间的相对顺序，所以可以从这一点入手。直接枚举排列最终复杂度为 $O(m!T)$，仍然不够优秀，还需要再优化。

设有 $\text{dp}$ 函数 $f_s(u,0/1)$，钦定集合 $s\sube U=\{0,1,..,m-1\}$，且 $U-s$ 中元素对应的数对应均大于 $s$ 中元素对应的数，当前在表达树上的节点 $u$，且子树 $u$ 中是 （$s$ 其中之一元素胜出的方案数）/（ $U-s$ 其中之一胜出的方案数）。

若 $u$ 对应的操作符是 ```<```，则有转移
$$
\begin{aligned}
&f_s(u,0)=f_s(L_u,0)\cdot f_s(R_u,0)+f_s(L_u,0)\cdot f_s(R_u,1)+f_s(L_u,1)\cdot f_s(R_u,0)\\
&f_s(u,1)=f_s(L_u,1)\cdot f_s(R_u,1)
\end{aligned}
$$
若 $u$ 对应的操作符是 ```>```，则有转移
$$
\begin{aligned}
&f_s(u,1)=f_s(L_u,1)\cdot f_s(R_u,1)+f_s(L_u,0)\cdot f_s(R_u,1)+f_s(L_u,1)\cdot f_s(R_u,0)\\
&f_s(u,0)=f_s(L_u,0)\cdot f_s(R_u,0)
\end{aligned}
$$
若 $u$ 对应的操作符是```?```，则相当于上面两种转移累加起来，合并同类项后效果就是
$$
\begin{aligned}
f_s(u,1)=f_s(u,0)=(f_s(L_u,0)+f_s(L_u,1))\cdot(f_s(R_u,0)+f_s(R_u,1))\\

\end{aligned}
$$
设 $rt$ 是表达式树的根节点，对于第 $i$ 列中第 $j$ 个数 $A_j[i]$，第 $i$ 中小于 $A_j[i]$ 的数的集合是 $s$，则通过容斥可以 $A_j[i]$ 最终胜出的次数是 $f_s(rt,1)-f_{s\cup\{j\}}(rt,1)$。

若同一列中存在两个数 $A_j[i]=A_k[i]$ 则将 $j$ 与 $k$ 之间的大小关系也纳入比较。

[P7516 [省选联考 2021 A/B 卷] 图函数](https://www.luogu.com.cn/problem/P7516) 首先可以观察到，对于每个 $u$，若一个 $v(v< u)$ 没有被删除（不对 $cnt$）有贡献，则 $v$ 存不存在对以后的点是否会被删除没有影响，这是因为若 $v$ 不在 $u$ 的强连通分量里，则 $v$ 不会影响以后的点与 $u$ 的强连通性。

故对于 $u$​，$v(v<u)$​ 能够被删除当且仅当只使用 $[v,n]$ 里的点， $u,v$​​ 能够互相到达。

对于一个边集 $G$，设 $a_G(u,v)$ 表示 $u$ 与 $v$ 是否能只使用 $[v,n]$ 里的点互相到达。

原来的问题是不断删边，对每个边集 $G_i$ （包含 $[i,m]$ 里的边），求出所有满足 $a_{G_i}(u,v)$的点对的个数，不妨将时间轴倒过来，变成一个不断加边的过程，而加边只可能会使某些 $a_{G_i}(u,v)=0$ 的点对变为 $a_{G_i}(u,v)=1$，之后 $a_{G_i}(u,v)$ 就一直等于 $1$​。所以可以求出使每个点对 $u,v$ 满足 $a_{G_i}(u,v)=1$ 的最小的 $i$，于是对于 $1\le j\le i$，一定有 $a_{G_j}(u,v)=1$​，记这样的 $i$ 为 $f(u,v)$。

然后就用与 $\text{Floyd}$ 类似方法 $\text{dp}$ 出  $f(u, v)$。

```cpp
for(re int i = n; i >= 1; --i){
    _rfor(j, i+1, n) _rfor(k, i+1, n){
        f[i][j] = max(f[i][j], min(f[i][k], f[k][j]));
        f[j][i] = max(f[j][i], min(f[j][k], f[k][i]));
    }
}
```

[P3084 [USACO13OPEN]Photo G](https://www.luogu.com.cn/problem/P3084) 

[P8108 [Cnoi2021]绀珠传说](https://www.luogu.com.cn/problem/P8108) 考虑每次消除的时候，将相邻的格子连边，考察它在游戏开始前的形态：

我们发现只有相邻的列之间有连边，且连边一定是不交的；反之，如果连边满足前面的约束，一定存在一种消除方式使得连边的格子在一次操作内被消除。

那么我们需要最大化连边数量，而由于第一条性质，不同列的连边之间互不影响，于是我们只用考虑两列之间的连边。

用树状数组辅助 $\text{dp}$ 即可，时间复杂度 $O(n^2\log n)$。

[P6764 [APIO2020]粉刷墙壁](https://www.luogu.com.cn/problem/P6764) 设 $yes(i,j)$ 表示第 $i$ 钟颜色是否能被承包商 $j$ 染色，$f(i,j)$ 表示第 $i$ 面墙由第 $j$ 个承包商粉刷时向前最长能匹配到的长度。

再详细说明一下 $f(i,j)$ 的定义，若 $f(i,j)=k$，则说明承包商序列 $[(j-k+1)\%M,...,M-1, 0,...,j-1,j]$ 能够粉刷墙序列 $[j-k+1, j]$。

很容易写出转移方程
$$
f(i,j)=\left\{\begin{aligned}&f(i-1,(j-1+M)\%M)+1 &(yes(C_i,j)=true) \\&0&(yes(C_i,j)=false)\end{aligned}\right.
$$
看起来时间复杂度是 $O(NM)$，但根据题目给出的条件可以知道 $\sum_{i,j}yes(i,j)\le 4\times 10^5$，说明不为 $0$ 的有效状态 $f(i,j)$ 的个数 $\le 4\times10^5$。

在程序中可以用 ```unordered_map``` 来存储 $yes(i,j)$，$f(i,j)$ 的动规转移可以用滚动数组优化掉第一维的空间。

[P9229 扩展九连环](https://www.luogu.com.cn/problem/P9229) 类似于汉诺塔，用递推的思想解决。记 $sub_i$ 表示 $str$ 长度为 $i$ 的后缀。对于某两个不同后缀 $sub_i,sub_j$，设 $k(i,j)=\min(i,j)$，简记 $k=k(i,j)$，则 $sub_i[1,k]$ 表示 $sub_i$ 长度为 $k$ 的前缀，$sub_j[1,k]$ 表示 $sub_j$ 长度为 $k$ 的前缀，令 $g(i,j)$ 表示从后往前数，$sub_i[1,k]$ 与 $sub_j[1,k]$ 第 $g(i,j)$ 位字符是首个不同的字符，即 $g(i,j)$ 表示$sub_i[1,k]$ 与 $sub_j[1,k]$ 最长公共后缀的长度加一，令 $f(i,j)$ 表示将 $sub_i[1,k]$ 变成 $sub_j[1,k]$ 最少需要多少步。

由定义显然可知 $f(i,j)=f(j,i)$ 和 $g(i,j)=g(j,i)$。

$g(i,j)$ 可以以 $O(n^2\log n)$ 的二分 + $\text{hash}$ 算出，也可以固定 $j$，通过递增地枚举 $i$ 以 $O(n)$ 求出 $g(*,j)$，方法类似于后缀数组中求 $\text{height}$ 数组的 $O(n)$ 算法，于是可以以 $O(n^2)$ 求出 $g(i,j)$。

$f$ 的递推方程是
$$
f(i,j)=\left\{\begin{aligned}
&f(i,j-g(i,j))+1+f(j-g(i,j),j)&(g(i,j)<k)\\
&1&(g(i,j)=k)\\
&0&(g(i,j)=k+1)
\end{aligned}\right.
$$
此外还需要设 $t(i)$ 表示将字符串 $0...0$（$i$ 个字符）变成 $sub_i$ 最少需要几步，记 $e_0$ 表示从后往前数，$str$ 的第 $e_0$ 位字符是首个不为 $0$ 的字符，则 $t$ 的递推方程是
$$
t(i)=\left\{\begin{aligned}
&t(i-e_0)+1+f(i-e_0,i)&(i>e_0)\\
&1&(i=e_0)\\
&0&(i<e_0)
\end{aligned}\right.
$$
有了 $f$ 与 $t$ 就能够求出答案了。

[P9415 「NnOI R1-T4」下楼](https://www.luogu.com.cn/problem/P9415) 写出转移后用线段树优化。

[SYSU20230902-D. Transition](https://codeforces.com/group/wmhDiB5PTN/contest/470807/problem/D) 首先靠人类智慧得到几个结论。然后设 $f_{i,j}$ 表示前 $i$ 个字符修改完后花费为 $j$ 的方案数，由于我们只关心最小花费的方案，第二维可以优化掉，当然第一维也可以用滚动数组优化掉。时间复杂度 $O(n)$。

#### 单峰单谷

[P7962 [NOIP2021] 方差](https://www.luogu.com.cn/problem/P7962)

[P7801 [COCI2015-2016#6] KRUMPIRKO](https://www.luogu.com.cn/problem/P7801) 设 $A=\sum a_i,\ C=\sum c_i$，其中一家店有 $y$ 个土豆总价为 $x$，则要最小化的式子是
$$
\frac{x(C-x)}{y(A-y)}
$$
答案的影响因素有两个，根据数据范围注意到 $y\le 500$，所以考虑固定其中一个因素，然后最小化另外一个因素。于是设 $f(i,j,k)$ 表示考虑了前 $i$ 袋土豆，有 $k$ 袋给了这家店，且土豆总数有 $j$ 时最小的 $x(C-x)$，然而 $x(C-x)$ 并不容易计算（要计算的话还要加多一维关于 $x$ 大小的信息），考虑到我们需要最小化的东西是关于 $x$ 的单峰函数，于是它的最小值一定是在 $x$ 最小或 $x$ 最大时取得，所以可改造 $\text{dp}$，即设 $f(i,j,k,0)$ 表示相应条件下最小的 $x$，$f(i,j,k,1)$ 表示相应条件下最大的 $x$，于是答案为
$$
cal(x) = x(C-x)\\
ans=\min_{1\le j\le A}\{\frac{cal(f(n,j,l,0))}{j(A-j)},\frac{cal(f(n,j,l,1))}{j(A-j)}\}
$$

[CF1239E Turtle](https://www.luogu.com.cn/problem/CF1239E) 确定了一种分配方式后，乌龟能吃到多少只取决于它转向的位置，设乌龟在第 $i$ 个位置转向时能得到能量 $f(i)$。手玩一把后可以发现最优的分配策略一定满足上面一排是单增序列，下面一排是单减序列，说明 $f(i)$ 的导函数（差分）就是单增的，于是 $f(i)$ 是下凸函数，所以乌龟仅能在 $f(1)$ 与 $f(n)$ 得到最大的能量。有了这个观察后仅剩的决策就是分配哪些食物给上一排，分配哪些食物给下一排。首先肯定要将能量最小和次小的食物安排在起点和终点，剩下的食物平均分配给上一排和下一排，这就是一个背包问题了。











