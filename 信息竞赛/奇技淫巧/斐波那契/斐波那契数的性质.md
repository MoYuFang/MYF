本文起笔于```2021.10.12```

斐波那契数列的定义是：
$$
fib(0)=fib(1)=1,fib(i+1)=fib(i)+fib(i-1)
$$


斐波那契数的性质：

(1) 通项：
$$
fib(n) = \frac{1}{\sqrt{5}}\cdot \left[\left(\frac{1+\sqrt{5}}{2}\right)^{n+1}-\left(\frac{1-\sqrt{5}}{2}\right)^{n+1} \right]
$$
从通项可以看出大小不超过 $n$​ 的斐波那契数的个数为 $O(\log_{1.618} n)$​，且个数比 $\log_2 n$ 稍大，这个性质很重要。

(2) 斐波那契前缀和
$$
fib(1)+\sum_{i=0}^{n-2}fib(i) = fib(n)\\
\sum_{i=0}^{n-2}fib(i) = fib(n)-1
$$
来看一道例题：

![斐波那契表达式](..\..\题面\oiclass P3894 斐波那契.png)



考虑朴素 $\text{dp}$，显然是枚举每个斐波那契数，把问题当做 $\text{01}$ 背包。

```cpp
_rfor(j, 1, fcnt)
    for(re int i = min(maxn, fib[j+1]+fib[j]-1), t = fib[j]; i >= t; --i)
        f[i] = (f[i] + (ll)f[i-t]*t) % mod;
```

但这样的时间复杂度就为 $O(n\log n)$ ，不够优秀。

注意性质：斐波拉契数列前缀和 $g[i-2]=f[i]−1$​​​​​ 。
于是，对于一个数 $n$​​​​ ，考虑最大的两个小于等于它的斐波拉契数，设为 $t(n,0)$​​​​、$t(n,1)$​​​​。则它俩的选择情况是对立事件，即二者必选其中一个。
于是考虑 $\text{dp}$​​​​，设 $f(i,0)$​​​​ 表示构成i的斐波拉契表示中选择了 $ t(n,0)$​​​​ 的答案， $f(i,1)$​​​​ 则表示选择了$t(n,1)$​​​​ 的答案。剩下的就是个简单 $\text{dp}$​​​​​ 转移了。时空复杂度均为 $O(n)$​ 。

```cpp
f[0][0] = f[1][0] = f[1][1] = fib[0] = fib[1] = 1;
re int p = 2, a = fib[1], b = fib[2];
_rfor(i, 2, maxn){
    if(fib[p+1] <= i) a = b, b = fib[++p];
    f[i][0] = (ll)(f[i-b][1] + f[i-b][0]) * b % mod;
    f[i][1] = (ll)(f[i-a][1] + ((a>i-a)?f[i-a][0]:0)) * a % mod;
}
```

之所以能优化掉枚举物品那一维 $\text{dp}$ 是因为考虑完 $t(n,0)$ 和 $t(n,1)$ 后，因为斐波那契数前缀和的性质，所以前面的体积不会再考虑它们两个了，所以可以省去一维。

