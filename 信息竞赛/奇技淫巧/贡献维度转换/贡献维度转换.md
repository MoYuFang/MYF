### 贡献维度转换

[树上统计](..\..\题面\树上统计.png) 

先看这道题，如果以枚举每个区间 $[l,r]$ 然后算对应的贡献，因为每个区间基本上是贡献不同的，无法通过合并同类项降低时间复杂度，那么无论如何也不可能把复杂度降到 $O(n^2)$ 以下。但是注意到每个区间贡献的组成部分是个数为 $O(n)$ 边，这可比 $O(n^2)$ 低很多，于是考虑转换贡献的维度，把枚举每个区间换成枚举每条边，然后计算有几个区间通过它得出它对答案的贡献（相当于另一种合并同类项），然后通过正难则反+并查集+```set```+$\text{dsu on tree}$ 求出即可。

[nkoj P8438路径权值](http://oi.nks.edu.cn/zh/Problem/Details/8438) 

这题同样也是，直接枚举每个点，然后枚举它到每个点的路径权值的复杂度一定至少是 $O(n^2)$，但容易注意到对每个点的路径权值有贡献的边的数量只有 $O(n)$，于是考虑转换贡献的维度，我们去求每条边对哪些点有贡献，以及贡献多少，仔细思考后可以使用最大生成树的 $\text{Kruskal}$ 重构树，然后进一步的发现每条边的完成贡献的操作实际上只有两个区间加操作（本质上也是将贡献操作合并了同类项），再考虑到本题是进行完所有区间加后再查询每个点的权值，于是可以使用标记永久化的技巧。

总结上述两题，通过转换贡献的维度，将复杂度高的那一维转换为复杂度低的那一维，有时可以发现新维度下同类项的合并变得更明显和轻松了。

[P5072 [Ynoi2015] 盼君勿忘](https://www.luogu.com.cn/problem/P5072) 先考虑区间 $[l,r]$ 的答案如何计算。子序列的个数有 $2^{r-l+1}$ 个，难以直接统计每个子序列的答案，但注意到区间中的数的种类至多 $r-l+1$ 个， 将贡献维度转换后变成计算每种数在多少个子序列出现，这样问题就变得容易了。

### 同类项合并

[[WC2017模拟1.22] 简单题](..\..\题面\[WC2017模拟1.22] 简单题.png) 

[oiclass P3685 Cicada拿衣服](..\..\题面\oiclass P3685 Cicada 拿衣服.png) 

[小L的刺绣](..\..\题面\小L的刺绣.gif)

[P5369 [PKUSC2018]最大前缀和](https://www.luogu.com.cn/problem/P5369) 中如果考虑以头元素与子集为状态进行 $\text{dp}$ 则难以转移。不妨固定最大前缀和，求该子集中最大前缀和为该固定值的排列数，至于前缀和的固定则可以是该子集所有元素之后，然后就容易转移了。

### 去除无效贡献

[nkoj P8437 删边](http://oi.nks.edu.cn/zh/Problem/Details/8437) 