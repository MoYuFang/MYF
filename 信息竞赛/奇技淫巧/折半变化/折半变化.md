本文起笔于```2021.10.11```。

先来看一道例题：



![小L的刺绣](..\..\题面\小L的刺绣.gif)

因为区间 $\gcd$ 满足区间可覆盖性，可以用 $\text{st}$ 表预处理做到 $O(\log R)$ 求出某区间的 $\gcd$，其中 $R$ 为数字的值域。

考虑枚举每个区间然后求出它的 $\gcd$ （设为 $x$）然后将 $x$ 插入 ```unordered_map``` ，但这样复杂度就是 $O(n^2 \log R)$ ，不够优秀。

这时该考虑 $\gcd$ 折半变化的性质了。

固定区间的左端点 $l$，然后让区间的右端点 $r$ 不断增加，注意到此时整个区间的 $\gcd$ 每次变化必然减少一半，所以在固定了区间左端点的情况下至多有 $\log R$ 种本质不同的区间。

于是考虑枚举区间左端点，然后一个一个的求出让区间 $\gcd$ 变化的 $r$ ，每次求 $r$ 可以用二分 + $\text{st}$ 表解决，然后插入进 ```unordered_map```。

复杂度是 $O(n\log n\log R)$。

$\text{st}$ 表的预处理复杂度 $O(n\log n \log R)$ 。

再来考虑另外一题 [Cicada拿衣服](http://oiclass.com/problem.php?cid=1732&pid=2)。

![Cicada 拿衣服](..\..\题面\oiclass P3685 Cicada 拿衣服.png)

显然的暴力解法是枚举每个区间 $[l,r]$，然后求出 $\text{excited}$ 然后区间覆盖，复杂度 $O(n^2)$。

想到区间按位与、按位或都是满足折半变化的，于是考虑固定区间左端点 $l$​ ，让 $r$​​​ 往右增。

令 $w1 = OR_{l,r}-AND_{l,r},\quad w2 = MIN_{l,r}-MAX_{l,r}$​。

$r$​​ 往右增的过程中 $w1$​​单调递减，$w2$ 单调递增，两者之和不一定满足单调性，无法二分。

但因为区间按位与和区间按位或各自至多变化 $O(\log R)$ 次，所以 $w1$  不同的区间只有 $O(2\log R)$ 种。

所以可以用二分一个一个地求出每个使 $w1$ 变化的 $r_i$，因为在 $w1$ 不变的区间 $[l,r_{i-1}]$ 至 $[l,r_i-1]$ 中 $w1+w2$​ 就满足单调递减了，于是可以二分。

对于区间静态查询最值、按位与、按位或则可以通过 $\text{st}$ 表以 $O(1)$ 实现。

于是时间复杂度就为 $O(n \cdot 2\log R \cdot \log n) = O(n\log n\log R)$。

满足折半变化的东西有：

1.  $\gcd$。
2. 按位与、按位或。

下面一题其实不算折半变化，但其中的思想与折半变化有点类似，故也归纳于此。

[P7335 [JRKSJ R1] 异或]([P7335 [JRKSJ R1\] 异或 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P7335))

看数据范围 $n\leq 3000$，于是可以暴力枚举区间然后算出每个区间的最大区间异或。

设 $g(l,r)$ 表示在区间 $[l,r]$ 选取一段子区间的区间异或值使得该子区间的区间异或最大，$g$ 可以用区间 $\text{dp}$ 以 $O(n^2)$ 预处理出来。

很容易想到一个套路 $\text{dp}$，设 $f(i,j)$ 表示考虑前 $i$ 个数被划分了 $j$ 时的最大值，转移方程是显然的。
$$
f(i,j) = \max_{j-1\leq k\leq i-1}\{f(k,j-1)+g(k+1,j)\}
$$
直接使用这个 $\text{dp}$ 显然是 $O(n^3)$，而且棘手的是，这个转移式看起来不能用单调队列、$\text{st}$ 表等数据结构优化，也想不出其它更好的 $\text{dp}$。

仔细分析性质，可以找到如下两条。
$$
f(k-1,j-1)\leq f(k,j-1)\\
g(k,i)\geq g(k+1,i)
$$
这说明了当 $i$ 和 $j$ 固定时，$f$ 是单调递增的，$g$ 是单调递减的。

然而两者之和不满足单调性，这两个性质好像也没用。

再仔细分析，这个 $\text{dp}$ 复杂度的瓶颈在于决策太慢了，得想办法看看能不能优化决策。

$f$ 与 $g$ 两者之和是波动的，这使得决策太多，但当两者其中之一是固定时，因为另一方是单调的，此时可以很快做出决策。

这个思路引导我们去思考 $f$ 和 $g$ 是否有其中之一不会变化太多次，$f$ 是 $\text{dp}$ 的主体，不太好考虑，于是考虑 $g$。

容易猜到 $g(*,i)$ 的变化应该不会很多，于是可以将 $g(*,i)$ 相同的段压缩一下，记录每一段 $g(*,i)$ 相同的左右端点，然后利用这一点去减少 $\text{dp}$ 转移的决策。 

再注意到题面中加入了一行```数据为随机生成```，这更加肯定了这个优化应该可行。

时间复杂度为 $O(n^2\cdot ?)=O(Accept)$。



































